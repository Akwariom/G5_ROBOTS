


/*
   Gaits Auto-Generated by NUKE
   Comm Protocol completely rebuit
   2019 AKWARIOM for Pulso.


  TO UPLOAD SKETCH VIA XBEE, REMEMBER TO PRESS THE RESET BUTTON ON THE ARBOTIX (JEAN CLAUDE'S HEAD)
*/
//___________________JEAN CLAUDE AUTO CONTROL
#include <ax12.h>
#include <BioloidController.h>
#include "nuke.h"
#include <EEPROM.h>
#include <avr/wdt.h>

#define AX12_HEXAPOD
int multiplier;
#define RIPPLE_SPEED    1
#define AMBLE_SPEED     3
#define TRIPOD_SPEED    5
#define TOP_SPEED      10

//___________________JEAN CLAUDE MANUAL CONTROL
const int servoCount = 18;
int servoPos[18]; // TO STORE
int pose[19]; // TO RECALL (first element is the length of the array - 1 !)
int interp_time = 20;
unsigned long now, lastUpdateMillis;
unsigned long sensorsInterval = 66;
unsigned long lastUpdateMillis2;
unsigned long checkInterval = 500;
//___________________COMMUNICATION
int index = -1;
unsigned char message[10];// maximum length of sendable message. Adjust to will
int checkSum;
String runMode = "AUTO";


//__________________DISTANCE SENSORS
#define sensor1Pin A0//A0 is physical A2....
#define sensor2Pin A1//A1 is physical A3....
#define sensor3Pin A2
#define sensor4Pin A3
#define sensor5Pin A4
#define sensor6Pin A5

//__________________SETUP__________
void setup() {

  pose[0] = 18; // (first element is the lenght of the array - 1 !)

  for (int i = 0; i < servoCount; i++)
  {
    servoPos[i] = 512;
  }

  pinMode(0, OUTPUT);
  // setup IK
  setupIK();
  gaitSelect(AMBLE_SMOOTH);
  // setup serial
  Serial.begin(38400);

  // wait, then check the voltage (LiPO safety)
  delay (1000);
  float voltage = (ax12GetRegister (2, AX_PRESENT_VOLTAGE, 1)) / 10.0;//Check on motor 2, the 1 is faulty for now
  Serial.print ("System Voltage: ");
  Serial.print (voltage);
  Serial.println (" volts.");
  if (voltage < 10.0)
    while (1);

  // stand up slowly
  bioloid.poseSize = 18;
  bioloid.readPose();
  doIK();
  bioloid.interpolateSetup(1000);
  while (bioloid.interpolating > 0) {
    bioloid.interpolateStep();
    delay(3);
  }
  multiplier = AMBLE_SPEED;
  tranTime = 500;

  Serial.print("EEPROM: ");
  Serial.println(EEPROM.length());

}
//______________END SETUP__________


//__________________LOOP__________
void loop() {
  //___________________________________________GET MESSAGE____________
  while (Serial.available())
  {
    unsigned char newChar = Serial.read();
    //digitalWrite(0,HIGH-digitalRead(0));//Turn Comm Led On
    //__________RECEIVED A 255 :  BEGINNING OF MESSAGE
    if (newChar == 0xff) {
      index = 0;
      checkSum = 0;
    }
    //__________RECEIVED A 254 :  END OF MESSAGE
    else   if (newChar == 0xfe) {
      index = 100;
    }
    else
    {
      //_________________Received something else than a 0xff or 0fe, well, it's our data
      if (index >= 0) {
        message[index] = (unsigned char) newChar;
        checkSum += (int)  message[index];
        index++; //unused but maybe add to check messages if they appear to be wrong
      }
    }
  }//END SERIAL AVAILABLE

  //_______________________________________TREAT MESSAGE____________
  if (index == 100) { //index==100, we received a new message that needs treating

    if (checkSum % 256 != 255) //Transmission Error
    {
      Serial.println("Transmission Error");
      index = -1;
    }
    else //Correct message received
    {
      updateHexapodParams();
      index = -1;
    }
    //
  }//END TREAT MESSAGE

  //____________________________________ACTIONS TO BE LOOPED ____________

  now = millis();
  if (now - lastUpdateMillis >= sensorsInterval)
  {
    lastUpdateMillis = now;
    sendSensorsStates();
  }

  if (now - lastUpdateMillis2 >= checkInterval)
  {
    lastUpdateMillis2 = now;
    checkErrorsAndRelax();
    getPositions();
  }

  if (runMode == "AUTO")
  {
    updateHexapodGaits();
  }
  else if (runMode == "MANU") //Do nothing, everything is done directly when getting message
  {
    // updateHexapodPos();
    // checkAndResetAX12Error();//IF the motor is in error, notify and reset.
  }
}
